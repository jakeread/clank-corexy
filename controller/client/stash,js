// aye, yeah, this is all stubs of code from Haystack... was running in where axlClient.js is now 

// -------------------------------------------------------- THE VM

let axl = new AXLClankVM(osap, PK.route().sib(0).pfwd().sib(1).pfwd().end())
// erp, 
setTimeout(axl.setup, 500)

// 550mm in x 
// 320mm in y 
let machineX = 550
let machineY = 380
let padWidth = 800
let padHeight = padWidth * (machineY / machineX)

// -------------------------------------------------------- Pad 

let pad = new Pad(10, 10, padWidth, padHeight, machineX, machineY)
let posns = []
let reqAwaiting = false
pad.addPoint([0, 0])
pad.onDragTarget = (pos) => {
  pos.push(-10)
  pos.push(0)
  if (reqAwaiting) return
  reqAwaiting = true
  axl.motion.setPosition(pos).then(() => {
    console.log('set...')
    reqAwaiting = false
  }).catch((err) => {
    console.error(err)
  })
}

pad.onUp = (pos) => {
  pos.push(10)
  pos.push(0)
  let check = () => {
    if (reqAwaiting) {
      setTimeout(check, 50)
    } else {
      axl.motion.setPosition(pos).then(() => {
        console.log('set...')
        reqAwaiting = false
      }).catch((err) => {
        console.error(err)
      })
    }
  }
  check()
}
/*
pad.onNewTarget = (pos) => {
  //pad.addPoint(pos)
  // append z, theta 
  pos.push(0)
  pos.push(0)
  axl.motion.setPosition(pos).then(() => {
    console.log(`set ${pos[0].toFixed(2)}, ${pos[3].toFixed(2)}, ${pos[2].toFixed(2)}`)
  }).catch((err) => {
    console.error(err)
  })
  /*
  axl.motion.addMoveToQueue({ target: pos, rate: 1000 }).then(() => {
    // console.log('pos set ok')
  }).catch((err) => { console.error(err) })
}
*/

// -------------------------------------------------------- Polling / Printing States 

let printer = new Button(10, padHeight + 20, 100, 140, 'data')

let publishNewPt = () => {
  axl.motion.getStates().then((states) => {
    pad.addPoint(states.positions)
    printer.setHTML(`
    COORD<br>
    ACCEL<br>
    ${states.accelerations[0].toFixed(2)}<br>
    ${states.accelerations[1].toFixed(2)}<br>
    VELOCITY<br>
    ${states.velocities[0].toFixed(2)}<br>
    ${states.velocities[1].toFixed(2)}<br>
    POSNS<br>
    ${states.positions[0].toFixed(2)}<br>
    ${states.positions[1].toFixed(2)}<br>
    `)
    setTimeout(publishNewPt, 50)
  })
}

setTimeout(publishNewPt, 500)

// -------------------------------------------------------- Path Test 

let pathTestButton = new Button(130, padHeight + 20, 100, 140, 'ingest test path...')
let runTestPath = async () => {
  for (let p = 1; p < testPath.length; p++) {
    try {
      await renderLine(testPath[p - 1], testPath[p],
        {
          scale: 1, pad: true, machine: true,
          offsetY: 0, offsetX: 0
        }
      )
      //await axl.motion.addMoveToQueue({target: testPath[p], rate: 500})
    } catch (err) {
      console.error(`path generates err at line ${p}`)
      console.error(err)
    }
  }
}

pathTestButton.onClick(() => {
  runTestPath()
})

// -------------------------------------------------------- SVG Import 

let svgImportButton = new Button(250, padHeight + 20, 100, 140, 'jorts !')
let svgImport = async () => {
  // pull svg as text, 
  let txt = testSVGs.waterBombSmall
  // consider pt-to-mm convert ? 
  // was 550mm to ... 1559.06 pts 
  let convert = 550 / 1559.06 
  // put it in the temp element (in index.html)
  const temp = document.querySelector("#temp");
  temp.innerHTML = txt;
  let paths = flattenSVG(temp);
  for (let l = 0; l < paths.length; l++) {
    if (paths[l].points[0] && paths[l].points[1]) {
      if( paths[l].points[0][0] < 0 || paths[l].points[0][1] < 0 || 
          paths[l].points[1][0] < 0 || paths[l].points[1][1] < 0 ){
          console.warn('-ve pts...')
          continue 
        }
      //console.log(paths[l].points[0])
      await renderLine(paths[l].points[0], paths[l].points[1],
        {
          scale: 0.6, pad: true, machine: true,
          offsetY: 0, offsetX: 0
        }
      )
    } else {
      console.warn('no second point defined here...', l)
    }
  }
  console.warn("done!")
}
svgImportButton.onClick(() => {
  svgImport()
})

// -------------------------------------------------------- Ingest XY -> XYZTheta

// -------------------------------------------------------- Move Ingest

// p1 is start [x,y], p2 is end...
let zUp = 10
let zDown = -1.5
let thetaOffset = 2.0 / 2 // was `2.0 / 2` for the creaser 
let thetaIncrements = 0
let lastTheta = 0
let renderLine = async (p1, p2, renderOptions = { scale: 1, pad: true, machine: false, offsetX: 0, offsetY: 0 }) => {
  try {
    p1 = JSON.parse(JSON.stringify(p1))
    p2 = JSON.parse(JSON.stringify(p2))
    // where's the vector math, pls ?
    p1[0] = p1[0] * renderOptions.scale + renderOptions.offsetX;
    p1[1] = p1[1] * renderOptions.scale + renderOptions.offsetY;
    p2[0] = p2[0] * renderOptions.scale + renderOptions.offsetX;
    p2[1] = p2[1] * renderOptions.scale + renderOptions.offsetY;
    // get unit vector 
    let unit = [p2[0] - p1[0], p2[1] - p1[1]]
    let sos = 0 // there should be a vector maths js lib ?
    for (let a = 0; a < 2; a++) {
      sos += unit[a] * unit[a]
    }
    let distance = Math.sqrt(sos)
    if (distance < 0.01 || isNaN(distance)) {
      console.warn('tossing zero length segment')
      return
    }
    // make ahn unit vector 
    for (let a = 0; a < 2; a++) {
      unit[a] = unit[a] / distance
    }
    // console.log(unit)
    let theta = Math.acos(unit[0])
    if (unit[1] < 0) {
      theta = 2 * Math.PI - theta
    }
    // do offset,
    let xThetaAdjust = Math.sin(theta) * thetaOffset;
    let yThetaAdjust = Math.cos(theta) * thetaOffset;
    /*
    p1[0] += xThetaAdjust; p2[0] += xThetaAdjust;
    p1[1] += yThetaAdjust; p2[1] += yThetaAdjust;
    */
    //console.warn(`${theta.toFixed(2)}, ${xThetaAdjust.toFixed(2)}, ${yThetaAdjust.toFixed(2)}`)
    /*
    // calcul8 theta 
    // unwrap theta... 
    // if new theta is small & last is very large, 
    // we want to wrap *up*
    if (theta <= (0.5 * Math.PI) && lastTheta >= (1.5 * Math.PI)) {
      thetaIncrements ++
    } else if (theta >= (1.5 * Math.PI) && lastTheta <= (0.5 * Math.PI)) {
      thetaIncrements --
    }
    lastTheta = theta
    theta = theta + 2 * Math.PI * thetaIncrements;
    */
    // now we have p1, p2, and a theta for both... 
    let moves = []
    moves[0] = [0, 0, 0, 0]
    moves[0][0] = p1[0]; moves[0][1] = p1[1];
    moves[0][2] = zUp
    moves[0][3] = theta
    // move 2 (index 1...) goes down 
    moves.push(JSON.parse(JSON.stringify(moves[0])))
    moves[1][2] = zDown
    // make linear move 
    moves.push(JSON.parse(JSON.stringify(moves[1])))
    moves[2][0] = p2[0]; moves[2][1] = p2[1];
    // move 3...
    moves.push(JSON.parse(JSON.stringify(moves[2])))
    moves[3][2] = zUp;
    // moves... 
    console.warn(moves)

    if (renderOptions.machine) {
      for (let m = 0; m < moves.length; m++) {
        console.warn(`sending... z ${moves[m][2]}`)
        //await TIMES.delay(10)
        await axl.motion.addMoveToQueue({ target: moves[m], rate: 250 })
      }
    }
    if (renderOptions.pad) {
      // draw 
      pad.addPoint([moves[0][0], moves[0][1]])
      pad.addPoint([moves[3][0], moves[3][1]])
    }
  } catch (err) {
    console.error(err)
  }
}
